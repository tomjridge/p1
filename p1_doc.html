<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Tom Ridge" />
  <meta name="date" content="2014-10-03" />
  <title>P1 documentation</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link href="data:text/css,%2F%2A%0A%20%2A%20Globals%0A%20%2A%2F%0A%0Abody%20%7B%0A%20%20font%2Dfamily%3A%20Georgia%2C%20%22Times%20New%20Roman%22%2C%20Times%2C%20serif%3B%0A%20%20color%3A%20%23222%3B%0A%7D%0A%0Ah1%2C%20%2Eh1%2C%0Ah2%2C%20%2Eh2%2C%0Ah3%2C%20%2Eh3%2C%0Ah4%2C%20%2Eh4%2C%0Ah5%2C%20%2Eh5%2C%0Ah6%2C%20%2Eh6%20%7B%0A%20%20margin%2Dtop%3A%200%3B%0A%20%20font%2Dfamily%3A%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0A%20%20font%2Dweight%3A%20normal%3B%0A%20%20color%3A%20%23333%3B%0A%7D%0A%0Ah1%20%7B%0A%20%20%20%20font%2Dsize%3A%2040px%3B%0A%7D%0A%0A%2Etitle%20%7B%0A%20%20%20%20font%2Dsize%3A%2060px%3B%0A%7D%0A" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">P1 documentation</h1>
<h2 class="author">Tom Ridge</h2>
<h3 class="date">2014-10-03</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#meta">Meta</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#other-sources-of-information-p1-ocamldoc-p1-source-code">Other sources of information: P1 ocamldoc, P1 source code</a></li>
<li><a href="#substrings">Substrings</a></li>
<li><a href="#terminal-parsers-and-the-type-of-parsers">Terminal parsers and the type of parsers</a></li>
<li><a href="#combinators-and-the-semantic-action-function">Combinators and the semantic action function</a></li>
<li><a href="#left-recursive-grammars">Left-recursive grammars</a></li>
<li><a href="#memoization">Memoization</a></li>
</ul>
</div>
<h1 id="meta">Meta</h1>
<p>This documentation is stored on github, user <code>tomjridge</code>, repository <code>p1.wiki</code>. It is intended to be formatted to html using pandoc, but should be readable under the github wiki interface. Periodically the html version of this document is placed in the main <code>p1</code> repository.</p>
<ul>
<li><a href="http://tomjridge.github.io/p1/p1_doc.html" class="uri">http://tomjridge.github.io/p1/p1_doc.html</a> - doc formatted by pandoc</li>
</ul>
<h1 id="introduction">Introduction</h1>
<p>P1 is a combinator parsing library for OCaml. The main feature is:</p>
<ul>
<li>P1 can parse arbitrary context-free grammars, including those with left recursion</li>
</ul>
<p>However, in order to handle all context-free grammars, the interface to P1 is slightly more complicated than that for standard combinator parsers.</p>
<p>The theory behind P1 is explained in the paper <span class="citation">(Ridge 2011)</span>. In the following sections, I will explain informally how P1 can be used to parse arbitrary context-free grammars.</p>
<h1 id="other-sources-of-information-p1-ocamldoc-p1-source-code">Other sources of information: P1 ocamldoc, P1 source code</h1>
<p>The build directory Makefile contains a target to build ocamldoc documentation for P1. This is a useful source of information. The interface is defined in the <code>p1_lib.mli</code> file, and we include excerpts from this file in the following sections.</p>
<ul>
<li><a href="http://tomjridge.github.io/p1/ocamldoc/" class="uri">http://tomjridge.github.io/p1/ocamldoc/</a> - ocamldoc</li>
</ul>
<p>In addition, the entire code for the core of P1 is under 40 lines. In conjunction with <span class="citation">(Ridge 2011)</span> it should be easy to understand the functioning of P1 in its entirety. The following sections describe the interface, for users who do not want to grapple with the details of <span class="citation">(Ridge 2011)</span>.</p>
<h1 id="substrings">Substrings</h1>
<p>The API is defined in the file <code>p1_lib.mli</code>.</p>
<p>P1 can be used as a lexerless parser (to parse strings directly), or it can be used with a lexer. The input is typically represented by a type parameter <code>'a</code>. We often work with parts of the input string, rather than the entire input. Splitting strings into pieces (i.e. smaller strings) is inefficient, so we introduce a type of substrings.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a substring = [ <span class="dt">`SS</span> <span class="kw">of</span> 'a * <span class="dt">int</span> * <span class="dt">int</span> ]</code></pre>
<p>The idea is that a substring <code>`SS(s,i,j)</code> represents the part of the input string <code>s</code> between indexes <code>i</code> and <code>j</code> (where <span class="math">0 ≤ <em>i</em> ≤ <em>j</em> ≤ |<em>s</em>|</span>).</p>
<p>Parsers don't work directly with substrings, because they need to maintain additional information about the parent parses that are already in progress (this is tracked by the &quot;parsing context&quot;, as described in <span class="citation">(Ridge 2011)</span>). For this reason, parsers work with a type <code>'a ty_input</code> rather than <code>'a substring</code>. Effectively this type contains a substring, and some &quot;extra information&quot; (the parsing context). However, the user should never be exposed to the parsing context. Hence, we only allow the user access to the substring component.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> 'a ty_input
<span class="kw">val</span> toinput : 'a substring -&gt; 'a ty_input
<span class="kw">val</span> substring_of_input : 'a ty_input -&gt; 'a substring</code></pre>
<h1 id="terminal-parsers-and-the-type-of-parsers">Terminal parsers and the type of parsers</h1>
<p>In traditional parsing presentations, terminal parsers correspond to a single character (or token) in the input. We lift this restriction, and allow (more-or-less) arbitrary terminal parsers.</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> ('a, 'b) ty_parser = 'a ty_input -&gt; ('b * 'a substring) <span class="dt">list</span></code></pre>
<p>Here, <code>'a</code> is the underlying type of the input (typically <code>string</code>), and <code>'b</code> is the type of result. As with traditional combinator parsers, we are parsing prefixes of the input, and so the list of results is a list of pairs, where each pair contains a value of type <code>'b</code>, and a substring indicating the remainder of the input that has still to be parsed.</p>
<p>A terminal parser can be constructed directly. For example, to parse a single character <code>1</code> from the input, we do the following:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> a1 : (<span class="dt">string</span>,<span class="dt">int</span>) ty_parser = (<span class="kw">fun</span> i0 -&gt;
    <span class="kw">let</span> <span class="dt">`SS</span>(s,i,j) = substring_of_input i0 <span class="kw">in</span>
    <span class="kw">if</span> i &lt; j &amp;&amp; s.[i] = <span class="ch">'1'</span> <span class="kw">then</span> 
      [(<span class="dv">1</span>,<span class="dt">`SS</span>(s,i+<span class="dv">1</span>,j))]
    <span class="kw">else</span>
      [])</code></pre>
<p>The library provides some standard terminal parsers. For example, the above can be written as <code>(a &quot;1&quot;)</code>, where <code>a</code> is a function that takes a string and returns a parser that consumes exactly that string.</p>
<h1 id="combinators-and-the-semantic-action-function">Combinators and the semantic action function</h1>
<p>With non-left-recursive grammars, P1 functions like a traditional combinator parsing library. There are three main combinators. The sequential combinator <code>**&gt;</code> (written infix) sequences two parsers. The following is simple OCaml code to define the parser <code>p</code> as the parser <code>p1</code> followed by <code>p2</code>:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> p = p1 **&gt; p2 </code></pre>
<p>The alternative combination <code>p1 ||| p2</code> returns the results of parsing with <code>p1</code> and <code>p2</code>. In fact, it is defined using simple list concatenation, exactly as traditional combinator parsers.</p>
<p>Finally, the &quot;semantic action&quot; function <code>p &gt;&gt; f</code> applies a function <code>f</code> to each of the results of parsing with <code>p</code>.</p>
<p>The API gives the following types:</p>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">type</span> ('a, 'b) ty_parser = 'a ty_input -&gt; ('b * 'a substring) <span class="dt">list</span>

<span class="kw">val</span> ( &gt;&gt; ) : ('a,'b) ty_parser -&gt; ('b -&gt; 'c) -&gt; ('a,'c) ty_parser
<span class="kw">val</span> ( ||| ) : ('a,'b) ty_parser -&gt; ('a,'b) ty_parser -&gt; ('a,'b) ty_parser
<span class="kw">val</span> ( **&gt; ) : ('a,'b) ty_parser -&gt; ('a,'c) ty_parser -&gt; ('a, 'b*'c) ty_parser</code></pre>
<h1 id="left-recursive-grammars">Left-recursive grammars</h1>
<p>P1 handles left-recursive grammars by tracking parent parses that are already in progress. For example, suppose we are parsing a nonterminal <code>E</code> for the substring <span class="math"><em>S</em><sub><em>i</em>, <em>j</em></sub></span>. If there is a parent parse in progress for the same nonterminal, for the same substring, then the parse should be abandoned.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<h1 id="memoization">Memoization</h1>
<div class="references">
<h1>References</h1>
<p>Ridge, Tom. 2011. “Simple, Functional, Sound and Complete Parsing for All Context-Free Grammars.” In <em>CPP</em>, 103–18. Springer.</p>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The paper <span class="citation">(Ridge 2011)</span> makes it clear why this is a semantically reasonable thing to do. The formal definition involves the notion of &quot;good parse tree&quot;. The P1 parsing strategy returns all good parse trees, and these are essentially all the parse trees you are usually interested in. Semantically, you can typically reason as though you were working with all parse trees, and provided your parsing actions are &quot;reasonable&quot; (in a technical sense), after applying the semantic actions, you get all the results you expect.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
</body>
</html>
